import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

export const loginUser = createAsyncThunk(
  "user/loginUser",
  //The second parameter of the async func is always thunkAPI and we can use its
  //method rejectWithValue(error) to make the action resolve to rejected with the
  //error that we pass being send to action.payload instead of the usual action.error.
  async ({ email, password }, thunkAPI) => {
    const config = {
      headers: {
        "Content-Type": "application/json",
      },
    };

    try {
      const response = await axios.post(
        "/api/v1/login",
        { email, password },
        config
      );

      return response.data;
    } catch (error) {
      //error generated by axios has a field called response tht contains lots of info such as
      //data,status,statusText,headers,conig,request
      //data.error contains the error message sent by our backend.
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const registerUser = createAsyncThunk(
  "user/registerUser",
  async (formData, thunkAPI) => {
    try {
      const config = {
        headers: {
          "Content-Type": "application/json",
        },
      };

      const response = await axios.post("/api/v1/register", formData, config);

      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const loadUser = createAsyncThunk(
  "user/loadUser",
  async (dummy = 0, thunkAPI) => {
    try {
      const response = await axios.get("/api/v1/me");
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const logoutUser = createAsyncThunk(
  "user/logoutUser",
  async (dummy = 0, thunkAPI) => {
    try {
      await axios.get("/api/v1/logout");
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const updateUser = createAsyncThunk(
  "user/updateUser",
  async (userData, thunkAPI) => {
    try {
      const config = {
        headers: {
          "Content-Type": "application/json",
        },
      };
      const response = await axios.put("/api/v1/me/update", userData, config);
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const updatePassword = createAsyncThunk(
  "user/updatePassword",
  async (userData, thunkAPI) => {
    try {
      const config = {
        headers: {
          "Content-Type": "application/json",
        },
      };
      const response = await axios.put(
        "/api/v1/password/update",
        userData,
        config
      );
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const forgotPassword = createAsyncThunk(
  "user/forgotPassword",
  async (email, thunkAPI) => {
    try {
      const config = {
        headers: {
          "Content-Type": "application/json",
        },
      };
      const response = await axios.post(
        "/api/v1/password/forgot",
        { email },
        config
      );
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

export const resetPassword = createAsyncThunk(
  "user/resetPassword",
  async (userData, thunkAPI) => {
    try {
      const { token, password, confirmPassword } = userData;
      const config = {
        headers: {
          "Content-Type": "application/json",
        },
      };
      const response = await axios.put(
        `/api/v1/password/reset/${token}`,
        { password, confirmPassword },
        config
      );
      return response.data;
    } catch (error) {
      return thunkAPI.rejectWithValue(error.response.data.error);
    }
  }
);

function fillUserState1(state) {
  state.status = "loading";
}

function fillUserState2(state, action) {
  state.status = "succeeded";
  state.user = action.payload.user;
  state.isAuthenticated = true;
}

function fillUserState3(state, action) {
  state.status = "failed";
  state.error = action.payload;
}

export const userSlice = createSlice({
  name: "user",
  initialState: {
    status: "idle",
    user: {},
    isAuthenticated: false,
    isUpdated: false, //Set to true to indicate successful update of password/profile
    error: null,
    message: null,
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
    resetUpdate: (state) => {
      state.isUpdated = false;
    },
    resetMessage: (state) => {
      state.message = null;
    },
  },
  extraReducers(builder) {
    builder
      .addCase(loginUser.pending, fillUserState1)
      .addCase(loginUser.fulfilled, fillUserState2)
      .addCase(loginUser.rejected, fillUserState3)

      .addCase(registerUser.pending, fillUserState1)
      .addCase(registerUser.fulfilled, fillUserState2)
      .addCase(registerUser.rejected, fillUserState3)

      .addCase(loadUser.pending, fillUserState1)
      .addCase(loadUser.fulfilled, fillUserState2)
      .addCase(loadUser.rejected, (state) => {
        state.status = "failed";
        // state.error = action.payload;
        //For this dnt put in error msg as it is executed at App lvl everytime the app mounts
        //and it populates error of userState which is used in other places like
        //login page and ends up triggering error msg there.
      })

      .addCase(logoutUser.pending, fillUserState1)
      .addCase(logoutUser.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.isAuthenticated = false;
        state.user = {};
      })
      .addCase(logoutUser.rejected, fillUserState3)

      .addCase(updateUser.pending, fillUserState1)
      .addCase(updateUser.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.user = action.payload.user;
        state.isUpdated = true;
      })
      .addCase(updateUser.rejected, fillUserState3)

      .addCase(updatePassword.pending, fillUserState1)
      .addCase(updatePassword.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.isUpdated = true;
      })
      .addCase(updatePassword.rejected, fillUserState3)

      .addCase(forgotPassword.pending, fillUserState1)
      .addCase(forgotPassword.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.message = action.payload.message;
      })
      .addCase(forgotPassword.rejected, fillUserState3)

      .addCase(resetPassword.pending, fillUserState1)
      .addCase(resetPassword.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.user = action.payload.user;
        state.isAuthenticated = true;
        state.isUpdated = true;
      })
      .addCase(resetPassword.rejected, fillUserState3);
  },
});

export default userSlice.reducer;
export const { clearError, resetUpdate, resetMessage } = userSlice.actions;
export const userState = (state) => state.user;
